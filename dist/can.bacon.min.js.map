{"version":3,"file":"can.bacon.min.js","sources":["webpack/universalModuleDefinition","can.bacon.min.js","webpack/bootstrap cd96e01cd000bd486bc1*","./src/index.js","./src/index.js*","./src/can.js","./src/can.js*","./src/bacon.js","./src/bacon.js*","external \"Bacon\"*","external \"can\"*"],"names":["root","factory","exports","module","require","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","MapChangeEvent","args","event","which","how","value","oldValue","ListChangeEvent","type","index","isNaN","Error","toBaconObservable","ctx","ev","selector","stream","bacon","fromBinder","sink","cb","Next","chooseEventData","arguments","can","delegate","bind","undelegate","unbind","isComputed","toProperty","eventArgs","evName","getEventValueForBacon","oldBind","Observable","apply","oldDelegate","oldBindAndSetup","bindAndSetup","oldControlOn","Control","prototype","on","eventName","func","takeUntil","element","Map","target","_data","hasOwnProperty","List","_type","syncAsMap","map","val","key","attr","removeAttr","removeOthers","undefined","console","warn","syncAsList","list","isMapEvent","splice","concat","Math","min","length","replace","toCanCompute","compute","onValue","toCanMap","toCanList","Bacon"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Bacon\"), require(\"can\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"Bacon\", \"can\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"can.bacon\"] = factory(require(\"Bacon\"), require(\"can\"));\n\telse\n\t\troot[\"can.bacon\"] = factory(root[\"Bacon\"], root[\"can\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__) {\nreturn ","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Bacon\"), require(\"can\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"Bacon\", \"can\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"can.bacon\"] = factory(require(\"Bacon\"), require(\"can\"));\n\telse\n\t\troot[\"can.bacon\"] = factory(root[\"Bacon\"], root[\"can\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/ \t\t\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/******/ \t\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/ \t\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/ \t\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/ \t\n/******/ \t\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __moduleName = \"src/index\";\n\t__webpack_require__(1);\n\t__webpack_require__(2);\n\t\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __moduleName = \"src/can\";\n\tvar bacon = __webpack_require__(3);\n\tvar can = __webpack_require__(4);\n\tvar oldBind = can.bind;\n\tcan.bind = function(ev, cb) {\n\t  if (this instanceof bacon.Observable) {\n\t    return this;\n\t  } else if (cb) {\n\t    return oldBind.apply(this, arguments);\n\t  } else {\n\t    return toBaconObservable(this, ev);\n\t  }\n\t};\n\tvar oldDelegate = can.delegate;\n\tcan.delegate = function(selector, ev, cb) {\n\t  if (this instanceof bacon.Observable) {\n\t    return this;\n\t  } else if (cb) {\n\t    return oldDelegate.apply(this, arguments);\n\t  } else {\n\t    return toBaconObservable(this, ev, selector);\n\t  }\n\t};\n\tvar oldBindAndSetup = can.bindAndSetup;\n\tcan.bindAndSetup = function(ev, cb) {\n\t  return cb ? oldBindAndSetup.apply(this, arguments) : toBaconObservable(this, ev);\n\t};\n\tvar oldControlOn = can.Control.prototype.on;\n\tcan.Control.prototype.on = function(ctx, selector, eventName, func) {\n\t  if (!ctx) {\n\t    return oldControlOn.apply(this, arguments);\n\t  }\n\t  if (ctx instanceof bacon.Observable) {\n\t    return ctx.takeUntil(can.bind.call(this, \"destroyed\"));\n\t  }\n\t  if (typeof ctx === \"string\") {\n\t    func = eventName;\n\t    eventName = selector;\n\t    selector = ctx;\n\t    ctx = this.element;\n\t  }\n\t  if (func == null) {\n\t    func = eventName;\n\t    eventName = selector;\n\t    selector = null;\n\t  }\n\t  if (func == null) {\n\t    return toBaconObservable(ctx, eventName, selector).takeUntil(can.bind.call(this, \"destroyed\"));\n\t  } else {\n\t    return oldControlOn.apply(this, arguments);\n\t  }\n\t};\n\tcan.Map.prototype.bind = can.bindAndSetup;\n\tcan.Map.prototype.getEventValueForBacon = function(args) {\n\t  switch (args[0] && args[0].type) {\n\t    case \"change\":\n\t      return new MapChangeEvent(args);\n\t    default:\n\t      var target = args[0].target;\n\t      if (target._data && target._data.hasOwnProperty(args[0].type)) {\n\t        return args[1];\n\t      } else {\n\t        return args;\n\t      }\n\t  }\n\t};\n\tfunction MapChangeEvent(args) {\n\t  this.event = args[0];\n\t  this.which = args[1];\n\t  this.how = args[2];\n\t  this.value = args[3];\n\t  this.oldValue = args[4];\n\t}\n\tcan.List.prototype.getEventValueForBacon = function(args) {\n\t  switch (args[0] && args[0].type) {\n\t    case \"change\":\n\t    case \"set\":\n\t    case \"add\":\n\t    case \"remove\":\n\t      return new ListChangeEvent(args);\n\t    case \"length\":\n\t      return args[1];\n\t    default:\n\t      var target = args[0].target;\n\t      var _type = args[0].type;\n\t      if (target.hasOwnProperty(args[0].type)) {\n\t        return isNaN(_type) ? args[1] : args[1][0];\n\t      } else {\n\t        return args;\n\t      }\n\t  }\n\t};\n\tfunction ListChangeEvent(args) {\n\t  this.event = args[0];\n\t  switch (this.event.type) {\n\t    case \"change\":\n\t      this.index = isNaN(args[1]) ? args[1] : +args[1];\n\t      this.how = args[2];\n\t      this.value = this.how === \"remove\" ? args[4] : args[3];\n\t      this.oldValue = args[4];\n\t      break;\n\t    case \"set\":\n\t    case \"add\":\n\t    case \"remove\":\n\t      this.index = args[2];\n\t      this.how = this.event.type;\n\t      this.value = args[1];\n\t      this.oldValue = null;\n\t      break;\n\t    default:\n\t      throw new Error(\"Unexpected can.List event: \" + this.event.type);\n\t  }\n\t}\n\tfunction toBaconObservable(ctx, ev, selector) {\n\t  ev = ev == null ? \"change\" : ev;\n\t  var stream = bacon.fromBinder(function(sink) {\n\t    function cb() {\n\t      sink(new bacon.Next(chooseEventData(ctx, arguments)));\n\t    }\n\t    selector ? can.delegate.call(ctx, selector, ev, cb) : can.bind.call(ctx, ev, cb);\n\t    return (function() {\n\t      return selector ? can.undelegate.call(ctx, selector, ev, cb) : can.unbind.call(ctx, ev, cb);\n\t    });\n\t  });\n\t  if (ctx.isComputed) {\n\t    return stream.toProperty(ctx());\n\t  } else {\n\t    return stream;\n\t  }\n\t}\n\t;\n\tfunction chooseEventData(ctx, eventArgs, evName) {\n\t  if (ctx.isComputed) {\n\t    return eventArgs[1];\n\t  } else if (ctx.getEventValueForBacon) {\n\t    return ctx.getEventValueForBacon(eventArgs, evName);\n\t  } else {\n\t    return eventArgs[0];\n\t  }\n\t}\n\t\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __moduleName = \"src/bacon\";\n\tvar bacon = __webpack_require__(3);\n\tvar can = __webpack_require__(4);\n\tbacon.Observable.prototype.toCanCompute = function() {\n\t  var compute = arguments[0] !== (void 0) ? arguments[0] : can.compute();\n\t  this.onValue(compute);\n\t  return compute;\n\t};\n\tbacon.Observable.prototype.toCanMap = function() {\n\t  var map = arguments[0] !== (void 0) ? arguments[0] : new can.Map();\n\t  this.onValue((function(val) {\n\t    return syncAsMap(map, val);\n\t  }));\n\t  return map;\n\t};\n\tfunction syncAsMap(map, val) {\n\t  var key = val.hasOwnProperty(\"which\") ? val.which : val.index;\n\t  switch (val.how) {\n\t    case \"set\":\n\t      map.attr(key, val.value);\n\t      break;\n\t    case \"add\":\n\t      map.attr(key, val.value);\n\t      break;\n\t    case \"remove\":\n\t      map.removeAttr(key);\n\t      break;\n\t    case \"replace\":\n\t      map.attr(val.value, val.removeOthers);\n\t      break;\n\t    case undefined:\n\t      console.warn(\"Missing event type on change event: \", val);\n\t      map.attr(val);\n\t      break;\n\t    default:\n\t      console.warn(\"Unexpected event type: \", val.how);\n\t      map.attr(val);\n\t  }\n\t}\n\tbacon.Observable.prototype.toCanList = function() {\n\t  var list = arguments[0] !== (void 0) ? arguments[0] : new can.List();\n\t  this.onValue((function(val) {\n\t    return syncAsList(list, val);\n\t  }));\n\t  return list;\n\t};\n\tfunction syncAsList(list, val) {\n\t  var isMapEvent = val.hasOwnProperty(\"which\") || isNaN(val.index);\n\t  if (isMapEvent && val.how !== \"replace\") {\n\t    syncAsMap(list, val);\n\t  } else {\n\t    switch (val.how) {\n\t      case \"set\":\n\t        list.attr(val.index, val.value);\n\t        break;\n\t      case \"add\":\n\t        list.splice.apply(list, [val.index, 0].concat(val.value));\n\t        break;\n\t      case \"remove\":\n\t        list.splice(Math.min(val.index, !list.length ? 0 : list.length - 1), val.value ? val.value.length : 1);\n\t        break;\n\t      case \"replace\":\n\t        if (val.hasOwnProperty(\"removeOthers\")) {\n\t          list.attr(val.value, val.removeOthers);\n\t        } else {\n\t          list.replace(val.value);\n\t        }\n\t        break;\n\t      case undefined:\n\t        console.warn(\"Missing event type on change event: \", val);\n\t        list.replace(val.value);\n\t        break;\n\t      default:\n\t        console.warn(\"Unexpected event type: \", val.how);\n\t        list.replace(val.value);\n\t    }\n\t  }\n\t}\n\t\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = Bacon;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = can;\n\n/***/ }\n/******/ ])\n})\n","\n// The module cache\nvar installedModules = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(installedModules[moduleId])\n\t\treturn installedModules[moduleId].exports;\n\t\n\t// Create a new module (and put it into the cache)\n\tvar module = installedModules[moduleId] = {\n\t\texports: {},\n\t\tid: moduleId,\n\t\tloaded: false\n\t};\n\t\n\t// Execute the module function\n\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\t\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = modules;\n\n// expose the module cache\n__webpack_require__.c = installedModules;\n\n// __webpack_public_path__\n__webpack_require__.p = \"\";\n\n\n// Load entry module and return exports\nreturn __webpack_require__(0);","import \"./can\";\nimport \"./bacon\";\n","\"use strict\";\nvar __moduleName = \"src/index\";\nrequire(\"./can\");\nrequire(\"./bacon\");\n\n","module bacon from \"bacon\";\nmodule can from \"can\";\n\nvar oldBind = can.bind;\n/**\n * @function can.bind\n *\n * Extends `can.bind()` such that if it's called with only one argument (the\n * event name), or without any arguments, a `Bacon.EventStream` object is\n * created, instead of binding a callback to the event.\n *\n * The actual event values sent into the `EventStream` will vary depending on\n * the observed value.\n *\n * See http://canjs.com/docs/can.bind.html for documentation on the default\n * behavior.\n *\n * @param {Any} this - The object to bind events on. If this object is a\n *                     `Bacon.Observable`, `can.bind` is a no-op, returning\n *                     `this` immediately.\n * @param {String} [event=\"change\"] - Name of event to hook up to\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default (non-`can.bacon`) behavior.\n *\n * @returns EventStream | Any\n *\n * @example\n * can.bind.call(new can.Map(), \"change\").map(\".value\").log();\n *\n */\ncan.bind = function(ev, cb) {\n  if (this instanceof bacon.Observable) {\n    return this;\n  } else if (cb) {\n    return oldBind.apply(this, arguments);\n  } else {\n    return toBaconObservable(this, ev);\n  }\n};\n\nvar oldDelegate = can.delegate;\n/**\n * @function can.delegate\n *\n * Extends `can.delegate()` such that if it's called with only one or two\n * arguments (the selector, and the event name), a `Bacon.EventStream` object is\n * created, instead of binding a callback to the event.\n *\n * The actual event values sent into the `EventStream` will vary depending on\n * the observed value.\n *\n * See http://canjs.com/docs/can.delegate.html for documentation on the default\n * behavior.\n *\n * @param {Any} this - The object to bind events on. If this object is a\n *                     `Bacon.Observable`, `can.bind` is a no-op, returning\n *                     `this` immediately.\n * @param {Any} selector - The selector to delegate to.\n * @param {String} [event=\"change\"] - Name of event to hook up to.\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default (non-`can.bacon`) behavior.\n *\n * @returns EventStream | Any\n *\n * @example\n * can.delegate.call(window, \"a\", \"click\").doAction(\".preventDefault\").log();\n *\n */\ncan.delegate = function(selector, ev, cb) {\n  if (this instanceof bacon.Observable) {\n    return this;\n  } else if (cb) {\n    return oldDelegate.apply(this, arguments);\n  } else {\n    return toBaconObservable(this, ev, selector);\n  }\n};\n\n/**\n * @function can.compute#bind\n *\n * Replaces the default CanJS behavior of the `can.compute#bind()` method with\n * one that returns an `EventStream` of new `can.compute` values, if no\n * `callback` is provided to the `.bind()` call. If the `callback` is present,\n * this method reverts to the standard behavior of binding an event listener\n * directly.\n *\n * @param {String} [event=\"change\"] - Name of event to hook up to\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default (non-`can.bacon`) behavior.\n *\n * @returns EventStream | Computed\n *\n * @example\n * var compute = can.compute(1);\n * compute.bind().log(\"compute changed\");\n * compute(2);\n * // compute changed 2\n */\n\n\nvar oldBindAndSetup = can.bindAndSetup;\n// Mostly internal, but used to replace the `.bind()` behavior for all\n// Observables in Can.\ncan.bindAndSetup = function(ev, cb) {\n  return cb ?\n    oldBindAndSetup.apply(this, arguments) :\n    toBaconObservable(this, ev);\n};\n\nvar oldControlOn = can.Control.prototype.on;\n/**\n * @function can.Control#on\n *\n * Enhances `can.Control#on` (and by extension, `can.Component#events#on`) so it\n * can be used to listen to event streams in a memory-safe way, according to the\n * control/component's lifecycle. Also allows returning event streams from\n * regular event bindings.\n *\n * See http://canjs.com/docs/can.Control.prototype.on.html\n *\n *\n * @param {Any} [context=this.element] - The object to listen for events on. If\n *                                       this object is a `Bacon.Observable`,\n *                                       this method will immediately return a\n *                                       stream that ends automatically if the\n *                                       `this` (the Control or Component) is\n *                                       destroyed.\n * @param {String} [selector] - If provided, the selector to delegate to.\n * @param {String} [event=\"change\"] - The name of the event to listen to.\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default (non-`can.bacon`) behavior.\n *\n * @returns EventStream | Observable | Number\n *\n * @example\n * ...\n * events: {\n *   inserted: function() {\n *     this.on(GlobalStreams.specialEvent).log(\"special event:\");\n *   }\n * }\n * ...\n * $(\"mycomponent\").remove() // logs 'special event: \\<end\\>'\n * GlobalStreams.specialEvent.push(\"whatever\"); // Nothing happens\n *\n * // The following are also equivalent:\n * this.on(scope, \"change\").log(\"Scope changed\")\n * this.on(scope).log(\"Scope changed\")\n *\n */\ncan.Control.prototype.on = function(ctx, selector, eventName, func) {\n  if (!ctx) {\n    return oldControlOn.apply(this, arguments);\n  }\n  if (ctx instanceof bacon.Observable) {\n    return ctx.takeUntil(can.bind.call(this, \"destroyed\"));\n  }\n  if (typeof ctx === \"string\") {\n    func = eventName;\n    eventName = selector;\n    selector = ctx;\n    ctx = this.element;\n  }\n  if (func == null) {\n    func = eventName;\n    eventName = selector;\n    selector = null;\n  }\n  if (func == null) {\n    return toBaconObservable(ctx, eventName, selector)\n      .takeUntil(can.bind.call(this, \"destroyed\"));\n  } else {\n    return oldControlOn.apply(this, arguments);\n  }\n};\n\n/**\n * @function can.Map#bind\n *\n * Replaces the default CanJS behavior of the `can.Map#bind()` method with one\n * that returns an `EventStream` of event objects or values if the `callback`\n * argument is not provided.\n *\n * The values in `EventStream` vary depending on the event being listened to.\n *\n * For named property events, the new value of the property is returned, as-is.\n *\n * For `\"change\"` events, `MapChangeEvent` objects are returned, with the\n * following properties:\n *\n * {\n *   event: Object // The CanJS event object.\n *   which: String // They attr/key affected by the event,\n *   how: \"add\"|\"remove\"|\"set\" // The type of operation,\n *   value: Any // For \"add\"/\"set\" events, the new value. For \"remove\" events,\n *                 the removed value.\n * }\n *\n * Note that this object fits the API required for `Bacon.toCanMap`, so the\n * `EventStream` returned by this function can be piped into a different\n * `can.Map` to partially or fully synchronise both maps.\n *\n * Additionally, The events from that `Map` changing can then be piped back into\n * the original `Map` without causing circularity issues, achieving two-way\n * binding between both objects. See example.\n *\n * @param {String} [event=\"change\"] - Name of event to hook up to\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default (non-`can.bacon`) behavior.\n *\n * @returns EventStream | `this`\n *\n * @example\n * // Binding\n * var map = new can.Map({x:1});\n * map.bind().log(\"map changed:\");\n * map.bind(\"x\").log(\"x property changed:\");\n * map.attr(\"x\", 2);\n * // map changed: {event: Object, which: \"x\", \"how\": \"set\", value: 2}\n * // x property changed: 2\n *\n * // Piping into a different Map\n * var map1 = new can.Map();\n * var map2 = map1.bind().toCanMap(new can.Map());\n * map1.bind().log(\"map1 changed:\");\n * map2.bind().log(\"map2 changed:\");\n *\n * map1.attr(\"x\", 1);\n * // map2 changed: {event: Object, which: \"x\", \"how\": \"add\", value:1}\n * // map1 changed: {event: Object, which: \"x\", \"how\": \"add\", value:1}\n * map2.attr(\"x\", 2);\n * // map1 changed: {event: Object, which: \"x\", \"how\": \"set\", value:2}\n * // map2 changed: {event: Object, which: \"x\", \"how\": \"set\", value:2}\n * console.log(map1.attr(), map2.attr());\n * // {x:2}, {x:2}\n */\ncan.Map.prototype.bind = can.bindAndSetup;\ncan.Map.prototype.getEventValueForBacon = function(args) {\n  switch (args[0] && args[0].type) {\n  case \"change\":\n    return new MapChangeEvent(args);\n  default:\n    var target = args[0].target;\n    if (target._data && target._data.hasOwnProperty(args[0].type)) {\n      // We found a named property change event, not a generic custom event\n      // (maybe, probably)\n      return args[1];\n    } else {\n      // If we don't know what the event is, return the arguments as-is\n      return args;\n    }\n  }\n};\n\nfunction MapChangeEvent(args) {\n  this.event = args[0];\n  this.which = args[1];\n  this.how = args[2];\n  this.value = args[3];\n  // This isn't documented because I want to pretend it doesn't exist :)\n  this.oldValue = args[4];\n}\n\n/**\n * @function can.List#bind\n *\n * Replaces the default CanJS behavior of the `can.List#bind()` method with one\n * that returns an `EventStream` of event objects or values if the `callback`\n * argument is not provided.\n *\n * The values in `EventStream` vary depending on the event being listened to.\n *\n * For named property events, the new value of the property is returned,\n * as-is. Both numerical properties (indices) and regular Map attrs can be\n * bound to.\n *\n * For the `\"length\"` events, the new length of the array is returned as-is.\n *\n * The rest of the events, namely `\"change\"`, `\"add\"`, `\"remove\"`, and `\"set\"`,\n * either `ListChangeEvent` or `MapChangeEvent` objects are returned from the\n * stream, depending on whether the modification involves a numerical key.\n\n * For events on numerical properties, `ListChangeEvent` objects are returned,\n * with the following properties:\n *\n * {\n *   event: Object // The CanJS event object.\n *   index: Integer // They initial index of the change.\n *   how: \"add\"|\"remove\"|\"set\" // The type of operation,\n *   value: Array | Any // For \"add\" events, an array of added items.\n *                         For \"remove\" events, an array of removed items.\n *                         For \"set\", the single new value.\n * }\n *\n * For events on non-numerical properties, `MapChangeEvent` objects are\n * returned, using the same structure as `can.Map#bind()`:\n *\n * {\n *   event: Object // The CanJS event object.\n *   which: String // They attr/key affected by the event,\n *   how: \"add\"|\"remove\"|\"set\" // The type of operation,\n *   value: Any // For \"add\"/\"set\" events, the new value. For \"remove\" events,\n *                 the removed value.\n * }\n *\n * Note that these objects conform to the API required for `Bacon.toCanList` and\n * `Bacon.toCanMap` respectively, so the `EventStream` returned by this function\n * can be piped into a different `can.List` or `can.Map` to synchronise both.\n *\n * Unlike the stream returned by `can.Map#bind()`, this one cannot be used for\n * two-way binding out of the box, since `add` events will bounce back and forth\n * infinitely and cause an overflow. One-way binding works fine, though, and can\n * easily handle lists of different lengths.\n *\n * @param {String} [event=\"change\"] - Name of event to hook up to\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default (non-`can.bacon`) behavior.\n *\n * @returns EventStream | `this`\n *\n */\ncan.List.prototype.getEventValueForBacon = function(args) {\n  switch (args[0] && args[0].type) {\n  case \"change\":\n  case \"set\":\n  case \"add\":\n  case \"remove\":\n    return new ListChangeEvent(args);\n  case \"length\":\n    return args[1];\n  default:\n    // This is different from the can.Map version because can.Lists don't have\n    // the _data property.\n    var target = args[0].target;\n    var _type = args[0].type;\n    if (target.hasOwnProperty(args[0].type)) {\n      // We found a named property change event, not a generic custom event\n      // (maybe, probably).\n      // TODO - change the semantics here to check for integers. Floats should\n      // be treated as string keys.\n      return isNaN(_type) ? args[1] : args[1][0];\n    } else {\n      // If we don't know what the event is, return the arguments as-is\n      return args;\n    }\n  }\n};\n\nfunction ListChangeEvent(args) {\n  this.event = args[0];\n  switch (this.event.type) {\n  case \"change\":\n    // NOTE: This gets a string as the index for all change events.\n    this.index = isNaN(args[1])?args[1]:+args[1];\n    this.how = args[2];\n    // We take the liberty of changing these semantics for remove events. Aside\n    // from it being generally more convenient for filtering, this means that,\n    // aside from `this.oldValue` being weird, binding to \"change\" and filtering\n    // on `how` will give exactly equivalent results to just binding directly on\n    // the specific event type.\n    //\n    // NOTE: when you `can.List#pop()` on an empty array, you get\n    // `[undefined]` as the value, whereas splicing an empty array gets you\n    // `[]` as the value.\n    // See https://github.com/bitovi/canjs/issues/998\n    this.value = this.how === \"remove\" ? args[4] : args[3];\n    // This is only ever of interest for set events (we never spit out\n    // ListChangeEvent for length events)\n    this.oldValue = args[4];\n    break;\n  case \"set\":\n  case \"add\":\n  case \"remove\":\n    this.index = args[2];\n    this.how = this.event.type;\n    // NOTE: The docs say that this can be either one, or many things. I can\n    // only seem to get arrays out of this event, though.\n    this.value = args[1];\n    // NOTE: These events do not include oldValue.\n    this.oldValue = null;\n    break;\n  default:\n    throw new Error(\"Unexpected can.List event: \"+this.event.type);\n  }\n}\n\nfunction toBaconObservable(ctx, ev, selector) {\n  ev = ev == null ? \"change\" : ev;\n  var stream = bacon.fromBinder(function(sink) {\n    function cb() {\n      sink(new bacon.Next(chooseEventData(ctx, arguments)));\n    }\n    selector ?\n      can.delegate.call(ctx, selector, ev, cb) :\n      can.bind.call(ctx, ev, cb);\n    return ()=>selector ?\n      can.undelegate.call(ctx, selector, ev, cb) :\n      can.unbind.call(ctx, ev, cb);\n  });\n  if (ctx.isComputed) {\n    // Computes are a special case in the sense that it's fairly involved to set\n    // up a property, and we almost always want to bind computes as properties\n    // -- so in this specific case we return a property instead of a stream, to\n    // help sanity.\n    return stream.toProperty(ctx());\n  } else {\n    return stream;\n  }\n};\n\nfunction chooseEventData(ctx, eventArgs, evName) {\n  if (ctx.isComputed) {\n    return eventArgs[1];\n  } else if (ctx.getEventValueForBacon) {\n    return ctx.getEventValueForBacon(eventArgs, evName);\n  } else {\n    return eventArgs[0];\n  }\n}\n","\"use strict\";\nvar __moduleName = \"src/can\";\nvar bacon = require(\"bacon\");\nvar can = require(\"can\");\nvar oldBind = can.bind;\ncan.bind = function(ev, cb) {\n  if (this instanceof bacon.Observable) {\n    return this;\n  } else if (cb) {\n    return oldBind.apply(this, arguments);\n  } else {\n    return toBaconObservable(this, ev);\n  }\n};\nvar oldDelegate = can.delegate;\ncan.delegate = function(selector, ev, cb) {\n  if (this instanceof bacon.Observable) {\n    return this;\n  } else if (cb) {\n    return oldDelegate.apply(this, arguments);\n  } else {\n    return toBaconObservable(this, ev, selector);\n  }\n};\nvar oldBindAndSetup = can.bindAndSetup;\ncan.bindAndSetup = function(ev, cb) {\n  return cb ? oldBindAndSetup.apply(this, arguments) : toBaconObservable(this, ev);\n};\nvar oldControlOn = can.Control.prototype.on;\ncan.Control.prototype.on = function(ctx, selector, eventName, func) {\n  if (!ctx) {\n    return oldControlOn.apply(this, arguments);\n  }\n  if (ctx instanceof bacon.Observable) {\n    return ctx.takeUntil(can.bind.call(this, \"destroyed\"));\n  }\n  if (typeof ctx === \"string\") {\n    func = eventName;\n    eventName = selector;\n    selector = ctx;\n    ctx = this.element;\n  }\n  if (func == null) {\n    func = eventName;\n    eventName = selector;\n    selector = null;\n  }\n  if (func == null) {\n    return toBaconObservable(ctx, eventName, selector).takeUntil(can.bind.call(this, \"destroyed\"));\n  } else {\n    return oldControlOn.apply(this, arguments);\n  }\n};\ncan.Map.prototype.bind = can.bindAndSetup;\ncan.Map.prototype.getEventValueForBacon = function(args) {\n  switch (args[0] && args[0].type) {\n    case \"change\":\n      return new MapChangeEvent(args);\n    default:\n      var target = args[0].target;\n      if (target._data && target._data.hasOwnProperty(args[0].type)) {\n        return args[1];\n      } else {\n        return args;\n      }\n  }\n};\nfunction MapChangeEvent(args) {\n  this.event = args[0];\n  this.which = args[1];\n  this.how = args[2];\n  this.value = args[3];\n  this.oldValue = args[4];\n}\ncan.List.prototype.getEventValueForBacon = function(args) {\n  switch (args[0] && args[0].type) {\n    case \"change\":\n    case \"set\":\n    case \"add\":\n    case \"remove\":\n      return new ListChangeEvent(args);\n    case \"length\":\n      return args[1];\n    default:\n      var target = args[0].target;\n      var _type = args[0].type;\n      if (target.hasOwnProperty(args[0].type)) {\n        return isNaN(_type) ? args[1] : args[1][0];\n      } else {\n        return args;\n      }\n  }\n};\nfunction ListChangeEvent(args) {\n  this.event = args[0];\n  switch (this.event.type) {\n    case \"change\":\n      this.index = isNaN(args[1]) ? args[1] : +args[1];\n      this.how = args[2];\n      this.value = this.how === \"remove\" ? args[4] : args[3];\n      this.oldValue = args[4];\n      break;\n    case \"set\":\n    case \"add\":\n    case \"remove\":\n      this.index = args[2];\n      this.how = this.event.type;\n      this.value = args[1];\n      this.oldValue = null;\n      break;\n    default:\n      throw new Error(\"Unexpected can.List event: \" + this.event.type);\n  }\n}\nfunction toBaconObservable(ctx, ev, selector) {\n  ev = ev == null ? \"change\" : ev;\n  var stream = bacon.fromBinder(function(sink) {\n    function cb() {\n      sink(new bacon.Next(chooseEventData(ctx, arguments)));\n    }\n    selector ? can.delegate.call(ctx, selector, ev, cb) : can.bind.call(ctx, ev, cb);\n    return (function() {\n      return selector ? can.undelegate.call(ctx, selector, ev, cb) : can.unbind.call(ctx, ev, cb);\n    });\n  });\n  if (ctx.isComputed) {\n    return stream.toProperty(ctx());\n  } else {\n    return stream;\n  }\n}\n;\nfunction chooseEventData(ctx, eventArgs, evName) {\n  if (ctx.isComputed) {\n    return eventArgs[1];\n  } else if (ctx.getEventValueForBacon) {\n    return ctx.getEventValueForBacon(eventArgs, evName);\n  } else {\n    return eventArgs[0];\n  }\n}\n\n","module bacon from \"bacon\";\nmodule can from \"can\";\n\n/**\n * Returns a `can.compute` whose value changes whenever `observable`'s value\n * changes. If a compute is provided, it will be used instead of creating a new\n * one.\n */\nbacon.Observable.prototype.toCanCompute = function(compute=can.compute()) {\n  this.onValue(compute);\n  return compute;\n};\n\n/**\n * Returns a `can.Map` whose value is managed by a stream of incoming map change\n * events.\n *\n * If `map` is provided, it *must* be a `can.Map` instance, which will be used\n * instead of creating a new empty `can.Map`.\n *\n * Two kinds of event objects are accepted:\n *\n * @example\n * // Modification event. Modifies a single key.\n * {\n *   how: \"set\"|\"add\"|\"remove\", // The type of operation.\n *   which: String, // The key to modify.\n *   value: Any, // The value to set. Optional for `remove`.\n * }\n *\n * // Replacement event. Uses `.attr()` to replace multiple keys.\n * {\n *   how: \"replace\", // Must be this string.\n *   value: Object, // Object to replace with.\n *   removeOthers: Boolean // Passed to `.attr()`. See http://canjs.com/docs/can.Map.prototype.attr.html#sig_map_attr_obj__removeOthers__\n * }\n */\nbacon.Observable.prototype.toCanMap = function(map=new can.Map()) {\n  this.onValue((val)=>syncAsMap(map, val));\n  return map;\n};\n\nfunction syncAsMap(map, val) {\n  var key = val.hasOwnProperty(\"which\") ? val.which : val.index;\n  switch (val.how) {\n  case \"set\":\n    map.attr(key, val.value);\n    break;\n  case \"add\":\n    map.attr(key, val.value);\n    break;\n  case \"remove\":\n    map.removeAttr(key);\n    break;\n  case \"replace\":\n    map.attr(val.value, val.removeOthers);\n    break;\n  case undefined:\n    console.warn(\"Missing event type on change event: \", val);\n    map.attr(val);\n    break;\n  default:\n    console.warn(\"Unexpected event type: \", val.how);\n    // idk you're giving it to me so I'll shove it in. It's your own fault\n    // if it breaks. You voided the warranty. Be thankful for the log :)\n    map.attr(val);\n  }\n}\n\n/**\n * Returns a `can.List` whose value is managed by a stream of incoming list\n * and/or map change events.\n *\n * If `list` is provided, it *must* be a `can.List` instance, which will be used\n * instead of creating a new empty instance.\n *\n * Three kinds of event objects are accepted:\n *\n * @example\n * // Modification event. Modifies a single index or key.\n * {\n *   how: \"set\"|\"add\"|\"remove\", // The type of operation.\n *   which: String|Integer, // The key to modify.\n *   value: Any, // The value to set. For \"add\" on an Integer index, must be an\n *                  Array-like. Optional for `remove`.\n * }\n *\n * // Replacement event. Calls `.replace()`\n * {\n *   how: \"replace\", // Must be this string.\n *   value: Array-like, // Array-like to replace contents with.\n *   removeOthers: Boolean=true (optional) // Whether to keep trailing elements\n *                                            after value has been applied. If\n *                                            this argument is provided, the\n *                                            list will be replaced using\n *                                            `.attr()`. Otherwise, `.replace()`\n *                                            will be used. See:\n *                                            http://canjs.com/docs/can.List.prototype.attr.html#sig_list_attr_elements__replaceCompletely__\n * }\n */\nbacon.Observable.prototype.toCanList = function(list=new can.List()) {\n  this.onValue((val)=>syncAsList(list, val));\n  return list;\n};\n\nfunction syncAsList(list, val) {\n  var isMapEvent = val.hasOwnProperty(\"which\") || isNaN(val.index);\n  if (isMapEvent && val.how !== \"replace\") {\n    syncAsMap(list, val);\n  } else {\n    switch (val.how) {\n    case \"set\":\n      list.attr(val.index, val.value);\n      break;\n    case \"add\":\n      // TODO - tag lists and/or events with some magical number (like.. a\n      // batchnum-style thing) to prevent circular additions when two-way\n      // binding. Please name it: \"___PRAISE_THE_SUN___\"\n      list.splice.apply(list, [val.index, 0].concat(val.value));\n      break;\n    case \"remove\":\n      list.splice(Math.min(val.index, !list.length?0:list.length-1),\n                  val.value ? val.value.length : 1);\n      break;\n    case \"replace\":\n      if (val.hasOwnProperty(\"removeOthers\")) {\n        list.attr(val.value, val.removeOthers);\n      } else {\n        list.replace(val.value);\n      }\n      break;\n    case undefined:\n      console.warn(\"Missing event type on change event: \", val);\n      list.replace(val.value);\n      break;\n    default:\n      console.warn(\"Unexpected event type: \", val.how);\n      // idk you're giving it to me so I'll shove it in. It's your own fault\n      // if it breaks. You voided the warranty. Be thankful for the log :)\n      list.replace(val.value);\n    }\n  }\n}\n","\"use strict\";\nvar __moduleName = \"src/bacon\";\nvar bacon = require(\"bacon\");\nvar can = require(\"can\");\nbacon.Observable.prototype.toCanCompute = function() {\n  var compute = arguments[0] !== (void 0) ? arguments[0] : can.compute();\n  this.onValue(compute);\n  return compute;\n};\nbacon.Observable.prototype.toCanMap = function() {\n  var map = arguments[0] !== (void 0) ? arguments[0] : new can.Map();\n  this.onValue((function(val) {\n    return syncAsMap(map, val);\n  }));\n  return map;\n};\nfunction syncAsMap(map, val) {\n  var key = val.hasOwnProperty(\"which\") ? val.which : val.index;\n  switch (val.how) {\n    case \"set\":\n      map.attr(key, val.value);\n      break;\n    case \"add\":\n      map.attr(key, val.value);\n      break;\n    case \"remove\":\n      map.removeAttr(key);\n      break;\n    case \"replace\":\n      map.attr(val.value, val.removeOthers);\n      break;\n    case undefined:\n      console.warn(\"Missing event type on change event: \", val);\n      map.attr(val);\n      break;\n    default:\n      console.warn(\"Unexpected event type: \", val.how);\n      map.attr(val);\n  }\n}\nbacon.Observable.prototype.toCanList = function() {\n  var list = arguments[0] !== (void 0) ? arguments[0] : new can.List();\n  this.onValue((function(val) {\n    return syncAsList(list, val);\n  }));\n  return list;\n};\nfunction syncAsList(list, val) {\n  var isMapEvent = val.hasOwnProperty(\"which\") || isNaN(val.index);\n  if (isMapEvent && val.how !== \"replace\") {\n    syncAsMap(list, val);\n  } else {\n    switch (val.how) {\n      case \"set\":\n        list.attr(val.index, val.value);\n        break;\n      case \"add\":\n        list.splice.apply(list, [val.index, 0].concat(val.value));\n        break;\n      case \"remove\":\n        list.splice(Math.min(val.index, !list.length ? 0 : list.length - 1), val.value ? val.value.length : 1);\n        break;\n      case \"replace\":\n        if (val.hasOwnProperty(\"removeOthers\")) {\n          list.attr(val.value, val.removeOthers);\n        } else {\n          list.replace(val.value);\n        }\n        break;\n      case undefined:\n        console.warn(\"Missing event type on change event: \", val);\n        list.replace(val.value);\n        break;\n      default:\n        console.warn(\"Unexpected event type: \", val.how);\n        list.replace(val.value);\n    }\n  }\n}\n\n","module.exports = Bacon;","module.exports = can;"],"sourceRoot":"webpack-module://"}